<?php

namespace Scandio\lmvc\modules\assetpipeline\assetpipes;

use Scandio\lmvc\modules\assetpipeline\interfaces;
use Scandio\lmvc\modules\assetpipeline\controllers;
use Scandio\lmvc\modules\assetpipeline\util;

/**
 * Class AbstractAssetPipe
 * @package Scandio\lmvc\modules\assetpipeline\assetpipes
 *
 * Abstract asset pipeline to implement a set of interface functions while declaring process() abstract forcing each pipe
 * to implement it.
 *
 * After all, aggregating some functionality normally common for all pipes.
 */
abstract class AbstractAssetPipe implements interfaces\AssetPipeInterface
{

    protected
        $_fileLocator;

    protected static
        $_contentType;

    #Each pipe is responsible for this
    abstract public function process($asset, $options = []);

    function __construct()
    {
        #each pipe uses its own file locator
        $this->_fileLocator = new util\FileLocator();
    }

    /**
     * Sets the response content-type appropriately so that browsers display content correctly.
     */
    private function _setHttpHeaders()
    {
        #Nothing more complicated up to now
        header("Content-Type: " . static::$_contentType);
    }

    /**
     * Registers pipe at controller based on its pipe type.
     *
     * @param array $types  to be registered upon which pipe will get notified (e.g. [css]) also defines
     *                      controller path (e.g. assetpipe/css/styles.scss)
     */
    public static function register($types, $options = [])
    {
        #late static binding goodness
        controllers\AssetPipeline::registerAssetpipe($types, get_called_class(), $options);
    }

    /**
     * Gives stream of data which has been processed by pipe below in object-graph (css|js...-pipe).
     *
     * @param array $assets which should be processed by pipe
     * @param array $options to be possibly performed on assets
     *
     * @return string containing the stream which has been processed
     */
    public function serve($assets = [], $paths, $options = [])
    {
        $servedContent = "";

        #sets correct content type on output
        $this->_setHttpHeaders();

        #only if cache has been initialized
        if ($this->_fileLocator->initializeCache($assets, $paths, $options)) {
            #the served content is either read from cache
            $servedContent = $this->_fileLocator->isCached() ?
                $this->_fileLocator->fromCache() :
                #or generated by being processed and cached
                $this->_fileLocator->cache($this->process($this->_fileLocator->concat(), $options));
        }

        return $servedContent;
    }

    /**
     * Sets and delegates pipe's cache directory to file locator.
     *
     * @param string $cacheDirectory to be used for caching resources
     */
    public function setCacheDirectory($cacheDirectory)
    {
        $this->_fileLocator->setCacheDirectory($cacheDirectory);
    }

    /**
     * Sets and delegates asset-directory and fallbacks to file locator.
     *
     * @param string $assetDirectory where ordinary assets can be found
     * @param array $fallbacks if nothing was found, all these fallbacks shall be used
     */
    public function setAssetDirectory($assetDirectory, $fallbacks = [])
    {
        $this->_fileLocator->setAssetDirectory($assetDirectory, $fallbacks);
    }
}